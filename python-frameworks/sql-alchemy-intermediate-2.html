<!DOCTYPE html>
<html lang="sv" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stjernstr칬m Learning. - Flask Beginner</title>
    <link rel="stylesheet" href="../css/base.css" />
    <link rel="stylesheet" href="../css/article.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com/" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@500;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&display=swap"
      rel="stylesheet"
    />
    <link href="../css/prism.css" rel="stylesheet" />
    <!-- <link href="../css/prism-material-dark.css" rel="stylesheet" /> -->
    <script src="../js/prism.js" defer></script>
    <script src="../js/mainScripts.js" defer></script>
  </head>
  <body>
    <div class="progress-container">
      <div class="progress-bar" id="progress-bar"></div>
    </div>
    <main>
      <section class="dark-theme">
        <div class="toggle-container">
          <img
            src="https://stjernstrom.me/PVSPYH23/assets/moon.svg"
            alt="Dark Mode"
          />
        </div>
      </section>
      <h1>Flask - L칛tt och krafullt</h1>
      <h3 class="subtitle">PVSPYH23 Edition</h3>

      <article>
        <h2 id="section-head">
          Kapitel 8 - SQLAlchemy: Paginering och sortering
        </h2>
        <span class="anchor"><a href="#section-head">#</a></span>
        <p>
          Att dela upp inneh친llet i mindre delar och att kunna sortera det 칛r
          n친got som 칛r v칛ldigt vanligt i webbutveckling. Det 칛r ocks친 n친got som
          SQLAlchemy har inbyggt. Vi ska titta p친 hur vi kan anv칛nda oss av det
          i det h칛r kapitlet.
        </p>
        <p>
          Det 칛r inte bara anv칛ndbart f칬r att dela upp resultatet i mindre
          delar, det 칛r ocks친 bra f칬r serverbelastningen. Om vi har en
          s칬kfunktion som returnerar 5000 resultat, s친 칛r det inte s친
          anv칛ndarv칛nligt att visa alla resultat p친 en g친ng. Det 칛r ocks친
          v칛ldigt tungt f칬r servern att skicka tillbaks s친 mycket data. D칛rf칬r
          칛r det bra att dela upp resultatet i mindre delar och att anv칛ndaren
          kan bl칛ddra mellan sidorna.
        </p>

        <h2 id="section-1">Paginering</h2>
        <span class="anchor"><a href="#section-1">#</a></span>
        <p>
          Paginering 칛r en funktion som delar upp resultatet i mindre delar och
          visar bara en del i taget. Detta g칬r att vi kan visa tex 10 anv칛ndare
          친t g친ngen och anv칛ndaren kan sedan bl칛ddra mellan sidorna och detta
          har s친klart SQLAlchemy inbyggt. Vi kommer att forts칛tta anv칛nda v친r
          gamla kod, fr친n det tidigare kapitlet:
        </p>

        <ul>
          <li>
            <a
              href="https://github.com/mattiasstjernstrom/PVSPYH23/tree/main/sql-alchemy-S칬kfunktionen"
              target="_blank"
              >Hela koden hittar du p친 github!</a
            >
          </li>
        </ul>

        <p>
          F칬r att b칬rja anv칛nda paginering beh칬ver vi importera en ny modul:
        </p>

        <!-- prettier-ignore -->
        <pre class="language-python"><code class="language-python">from flask_sqlalchemy import Pagination</code></pre>

        <p>
          Vi beh칬ver ocks친 l칛gga till en ny parameter i v친r s칬kfunktion, som
          heter <code>page</code>. Detta 칛r den sida som anv칛ndaren 칛r p친. Nu
          kommer en till synes ganska avancerad kod. Men vi g친r igenom den
          tillsammans efter kodblocken eftersom den 칛r sv친r att dela upp:
        </p>

        <!-- prettier-ignore -->
        <pre class="language-python line-numbers"><code class="language-python">from flask import url_for, redirect</code></pre>

        <!-- prettier-ignore -->
        <pre class="language-python line-numbers"><code class="language-python"># app.py ...
@app.route("/sok", methods=["GET"])
def sok():
    page = request.args.get("page", 1, type=int)
    per_page = 10
    input = request.args.get("q")

    users_query = User.query.filter(
        or_(User.name.contains(input), User.email.contains(input))
    )

    users_pagination = users_query.paginate(
        page=page, per_page=per_page, error_out=False
    )
    users = users_pagination.items

    next_url = (
        url_for("sok", page=users_pagination.next_num)
        if users_pagination.has_next
        else None
    )
    prev_url = (
        url_for("sok", page=users_pagination.prev_num)
        if users_pagination.has_prev
        else None
    )

    return render_template(
        "sok.html", results=users, next_url=next_url, prev_url=prev_url
    )
# ...</code></pre>

        <h3>Kodsammanfattning</h3>
        <p>
          Vi b칬rjar (p친 <mark>rad 4</mark>) med att skapa en variabel som heter
          <code>page</code>. H칛r anv칛nder vi <code>request.args.get()</code> f칬r
          att h칛mta v칛rdet fr친n s칬kf칛ltet. Som type, m친ste vi ha
          <code>int</code> f칬r att tala om att det ska vara en siffra, annars
          vill den ha en str칛ng. Om det inte finns n친got v칛rde i s칬kf칛ltet s친
          s칛tter vi v칛rdet till 1. Vi vill ju alltid b칬rja p친 sidan ett!
        </p>
        <p>
          Vi skapar ocks친 en variabel som heter <code>per_page</code>. Detta 칛r
          antalet resultat som vi vill visa per sida. Vi skapar vi en s칬kfr친ga
          med <code>filter()</code> och <code>or_()</code>. Vi s칬ker efter
          anv칛ndare som inneh친ller <code>input</code> i namnet eller i eposten.
          Precis som i f칬rra exemplet.
        </p>
        <p>
          P친 <mark>rad 12</mark> skapar vi en variabel som heter
          <code>users_pagination</code>. H칛r anv칛nder vi
          <code>users_query</code> som vi skapade p친 rad 8. Vi anv칛nder
          funktionen <code>paginate()</code> f칬r att dela upp resultatet i
          mindre delar. H칛r anv칛nder vi <code>page</code> som vi skapade p친 rad
          4, <code>per_page</code> som vi skapade p친 rad 5.
        </p>

        <p>
          P친 <mark>rad 17 och 22</mark> skapar vi tv친 variabler som heter
          <code>next_url</code> och <code>prev_url</code>. Dessa 칛r l칛nkar som
          vi kommer att anv칛nda f칬r att bl칛ddra mellan sidorna. Vi anv칛nder
          <code>url_for()</code> f칬r att skapa l칛nkarna, det 칛r en funktion fr친n
          flask som skapar l칛nkar till olika sidor och till친ter oss att skicka
          med variabler i det h칛r fallet <code>(page=2 osv)</code>. Vi ocks친
          skickar med <code>page</code> som vi skapade p친 rad 4 och
          <code>users_pagination.next_num</code> och
          <code>users_pagination.prev_num</code> som 칛r SQLAlchemy's egna
          funktioner f칬r att hitta n칛sta och f칬reg친ende sida.
        </p>
        <p>
          Till sist s친 skickar vi med allt till render_template som vi beh칬ver
          f칬r att kunna visa resultat och att byta sida fram och tillbaks.
        </p>

        <h3>Adressen i s칬kf칛ltet d친?</h3>
        Om du g친r fram och tillbaks mellan sidorna nu s친 kommer du att se att
        orginal-queryn kommer att f칬rsvinna. Det ordnar vi l칛tt genom att l칛gga
        till ett par 칛ndringar i <code>url_for</code>:

        <!-- prettier-ignore -->
        <pre class="language-python line-numbers"><code class="language-python"># app.py ...
next_url = url_for('sok', q=input, page=users_pagination.next_num) \
    if users_pagination.has_next else None
prev_url = url_for('sok', q=input, page=users_pagination.prev_num) \
    if users_pagination.has_prev else None
# ...</code></pre>
        <h3>Kodsammanfattning</h3>
        <p>
          Det vi g칬r h칛r 칛r helt enkelt att vi anv칛nder oss av
          <code>url_for</code>s m칬jlighet att skicka med flera parametrar. Vi
          skickar med <code>q</code> som 칛r s칬kfr친ga och variabeln vi anv칛nder
          칛r <code>input</code> som vi skapade p친 rad 6 i det f칬rra exemplet.
          Och vi anv칛nder samma query-namn som vi skapade n칛r vi skapade
          s칬kf칛ltet i <code>index.html</code>. Allts친 <code>q</code>. Nu syns
          det i URL-en vad vi s칬kte p친 n칛r vi hoppar mellan sidorna. Det h칛r kan
          anses som standard n칛r man anv칛nder s칬k och paginering.
        </p>

        <h2 id="section-2">Sortering</h2>
        <span class="anchor"><a href="#section-1">#</a></span>

        <p>
          I det h칛r exemplet kan det vara lite on칬digt att g칬ra en sortering.
          Men ibland kan det vara smidigt att kunna sortera resultatet. S친 jag
          t칛nker att vi ska kunna sortera s칬k-resultaten i alfabetisk ordning.
          Vi b칬rjar med att l칛gga till en ny parameter i s칬kfunktionen som heter
          <code>sort</code>. Vi beh칬ver ocks친 l칛gga till en ny import:
        </p>

        <!-- prettier-ignore -->
        <pre class="language-python"><code class="language-python">from sqlalchemy import asc, desc</code></pre>

        <p>
          Vi beh칬ver ocks친 l칛gga till en ny parameter i s칬kfunktionen som heter
          <code>sort</code> och sedan kan vi l칛gga till en ny if-sats som ser ut
          s친h칛r:
        </p>

        <!-- prettier-ignore -->
        <pre class="language-python line-numbers"><code class="language-python"># app.py ...
sort = request.args.get("sort")

if sort == "name_asc":
    users_query = users_query.order_by(asc(User.name))
elif sort == "name_desc":
    users_query = users_query.order_by(desc(User.name))
elif sort == "email_asc":
    users_query = users_query.order_by(asc(User.email))
elif sort == "email_desc":
    users_query = users_query.order_by(desc(User.email))
# ...</code></pre>
        <span class="note"
          >Kom ih친g att l칛gga dessa rader n친gonstans mellan
          <code>if input</code>-satsen och <code>next_url</code>-variabeln</span
        >

        <h3>Kodsammanfattning</h3>
        <p>
          Det vi beh칬ver g칬ra h칛r 칛r att vi beh칬ver skapa en ny variabel som
          heter <code>sort</code> f칬r att kunna ta in v칛rdet fr친n s칬kf칛ltet.
          Sedan skapar vi en if-sats som kollar om <code>sort</code> 칛r lika med
          n친got av alternativen. Om det 칛r det s친 skapar vi en ny s칬kfr친ga mot
          databasen, med nya premisser. F칬r det anv칛nder vi
          <code>order_by()</code> f칬r att sortera upp resultatet. Vi anv칛nder
          <code>asc()</code> f칬r att sortera i stigande ordning och
          <code>desc()</code> f칬r att sortera i fallande ordning. Jag har valt
          att anv칛nda b친de <code>name</code> och <code>email</code> i det h칛r
          exemplet.
        </p>

        <p>
          Nu kan vi manuellt skriva till exempel
          <code>/sok?q=example&sort=email_desc</code> f칬r att sortera resultaten
          efter fallande ordning p친 anv칛ndarnas email-adresser.
        </p>

        <p>
          Vi vill ju s친 klart kunna g칬ra det med ett klick p친 v친r webbsida, s친
          vi skriver till en liten kod-snutt i <code>sok.html</code> och ett
          till칛gg i <code>app.py</code>:
        </p>
        <pre class="language-python line-numbers"><code># ...
return render_template(
    "sok.html",
    q=input, # Ny rad
    current_page=page, # Ny rad
    results=users,
    next_url=next_url,
    prev_url=prev_url,
)
#... </code></pre>

        <p>
          S친 enkelt fixar vi sorteringen i python. Nu kan vi skriva en liten
          kod-snutt i
          <code>sok.html</code> f칬r att skapa l칛nkar som sorterar resultatet:
        </p>

        <!-- prettier-ignore -->
        <pre class="language-jinja2 line-numbers"><code>{# templates/sok.html #}
&lt;div class="sort"&gt;
    &lt;h3&gt;Sortera efter:&lt;/h3&gt;
    &lt;a href="{{ url_for('sok', input=q, sort='name_asc', page=current_page) }}"&gt;Namn A-칐&lt;/a&gt;
    &lt;a href="{{ url_for('sok', input=q, sort='name_desc', page=current_page) }}"&gt;Namn 칐-A&lt;/a&gt;
    &lt;a href="{{ url_for('sok', input=q, sort='email_asc', page=current_page) }}"&gt;Email A-칐&lt;/a&gt;
    &lt;a href="{{ url_for('sok', input=q, sort='email_desc', page=current_page) }}"&gt;Email 칐-A&lt;/a&gt;
&lt;/div&gt;
{# ... #}</code></pre>
        <span class="note"
          >Ha som vana att anv칛nda <code>url_for()</code> i flask. Med dynamiska
          subfolders st칛ller det snabbt till problem!</span
        >
        <h2 id="section-3">Vad h칛nder under huven? (칬verkurs)</h2>
        <span class="anchor"><a href="#section-3">#</a></span>
        <p>
          Som en liten bonus s친 t칛nkte jag att vi skulle kolla lite p친 hur
          SQLAlchemy skapar SQL-querys. Det 칛r ju trots allt det som 칛r en av
          anledningarna till att vi anv칛nder oss av ett ORM som SQLAlchemy. Vi
          kan skriva ut v친ra querys med hj칛lp av
          <code>print()</code> precis som i python, men eftersom flask 칛r ett
          webb-ramverk och k칬rs hela tiden, s친 fungerar det inte att skriva ut i
          terminalen. Vi beh칬ver skriva ut det i flask-konsolen. Det g칬r vi
          genom att 칬ppna en ny terminal i samma mapp och skriva
          <code>flask shell</code>. D친 칬ppnas en interaktiv python-shell med din
          app inladdad. Vi kan skriva ut querys genom att skriva s친h칛r:
        </p>

        <!-- prettier-ignore -->
        <pre class="language-python"><code>>>> from sqlalchemy import or_
>>> users_query = User.query.filter(or_(User.name.contains(input), User.email.contains(input)))
>>> print(users_query)
</code></pre>

        <p>Resultatet av denna query blir:</p>
        <!-- prettier-ignore -->
        <pre class="language-sql"><code class="language-sql">SELECT user.id AS user_id, user.name AS user_name, user.email AS user_email 
    FROM user 
    WHERE (user.name LIKE concat('%', %(name_1)s, '%')) OR (user.email LIKE concat('%', %(email_1)s, '%'))
        </code></pre>
        <p>Ganska sk칬nt att slippa skriva den sj칛lv va?</p>

        <p>
          Nu har vi bara en sak kvar att l칛ra om SQLAlchemy f칬r denna g친ng, det
          f칬rtj칛nar ett eget kapitel. Migrations. Ses d칛r! 游뱁
        </p>

        <ul>
          <li>
            <a
              href="https://github.com/mattiasstjernstrom/PVSPYH23/tree/main/sql-alchemy-PageSort"
              target="_blank"
              >Hela koden hittar du p친 github!</a
            >
          </li>
        </ul>
      </article>

      <section class="next">
        <a href="sql-alchemy-intermediate.html">&larr; F칬reg친ende kapitel</a>
        -
        <a href="sql-alchemy-intermediate-3.html">N칛sta kapitel &rarr;</a>
      </section>
    </main>
  </body>
</html>
